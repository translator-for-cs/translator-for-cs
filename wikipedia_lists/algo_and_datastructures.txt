Absolute performance guarantee
Abstract data type
(a,b)-tree
Accepting state
Ackermann's function
Active data structure
Acyclic directed graph
Adaptive heap sort
Adaptive Huffman coding
Adaptive k-d tree
Adaptive sort
Address-calculation sort
Adjacency list
Adjacency matrix
Adversary model
Algorithm
Algorithm BSTW
Algorithmic efficiency
Algorithm V
All pairs shortest path
Alphabet
Alpha Skip Search algorithm
Alternating path
Alternating Turing machine
Alternation
American flag sort
American National Standards Institute
Amortized cost
Ancestor
Antichain
Antisymmetric relation
Apostolico–Crochemore
Apostolico–Giancarlo algorithm
Approximate string matching
Approximation algorithm
Arborescence
Arithmetic coding
Arithmetic progression
Array data structure
Array index
Array merging
Array search
Articulation point
A* search algorithm
Assignment problem
Association list
Associative
Associative array
Asymptotic computational complexity
Augmenting path
Automata theory
AVL tree
Axiomatic semantics
Backtracking
Baillie-PSW primality test
Balanced binary search tree
Balanced binary tree
Balanced k-way merge sort
Balanced merge sort
Balanced multiway merge
Balanced multiway tree
Balanced quicksort
Balanced two-way merge sort
BANG file
Batcher sort
Baum Welch algorithm
BB alpha tree
BD-tree
Bellman–Ford algorithm
Benford's law
Best case
Best-case cost
Best-first search
Best, worst and average case
Biconnected component
Biconnected graph
Bidirectional bubble sort
Big O notation
Big-O notation
Binary decision diagram
Binary function
Binary GCD algorithm
Binary heap
Binary insertion sort
Binary knapsack problem
Binary priority queue
Binary relation
Binary search
Binary search tree
Binary tree
Binary tree representation of trees
Bingo sort
Binomial heap
Binomial tree
Bin packing problem
Bin sort
Bipartite graph
Bipartite matching
Bisection method
Bitonic sort
Bit vector
Bk tree
Block
Block addressing index
Blocking flow
Block search
Bloom filter
Blossom
Bogosort
Boogol
Boolean datatype
Boolean expression
Boolean function
Bottleneck traveling salesman
Bottom-up tree automaton
Boundary-based representation
Bounded error probability in polynomial time
Bounded queue
Bounded stack
Bounding volume hierarchy
Boyer–Moore–Horspool algorithm
Boyer–Moore string search algorithm
Bozo sort
BPP
Bradford's law
Branch
Branch and bound
Branching
Breadth-first search
Bresenham's algorithm
Brick sort
Bridge
British Museum algorithm
Brute force attack
Brute force search
Brute force string search
Brute force string search with mismatches
BSP-tree
B*-tree
B+ tree
B-tree
Bubble sort
Bucket
Bucket array
Bucketing method
Bucket sort
Bucket trie
Buddy memory allocation
Buddy tree
Build-heap
Burrows–Wheeler transform
Busy beaver
Byzantine generals
Cactus stack
Calculus of Communicating Systems
Calendar queue
Candidate consistency testing
Candidate verification
Canonical complexity class
Capacitated facility location
Capacity constraint
Cartesian tree
Cascade merge sort
Caverphone
Cayley–Purser algorithm
C curve
Cell probe model
Cell tree
Cellular automaton
Centroid
Chain
Chaining
Child node
Chinese postman problem
Chinese remainder theorem
Christofides algorithm
Christofides heuristic
Chromatic index
Chromatic number
Church–Turing thesis
Circuit complexity
Circuit value problem
Circular list
Circular queue
Clique
Clique problem
Clustering free
Coalesced hashing
Coarsening
Cocktail shaker sort
Codeword
Coding tree
Collective recursion
Collision resolution scheme
Colussi
Combination
Comb sort
Communicating sequential processes
Communicating Sequential Processes
Commutative
Compact DAWG
Compact trie
Comparison sort
Competitive analysis
Competitive ratio
Complement
Complete binary tree
Complete graph
Completely connected graph
Complete tree
Complexity
Complexity class
Computable
Computational tree logic
Computer configuration
Computer keyboard keys
Concave function
Concurrent flow
Concurrent read, concurrent write
Concurrent read, exclusive write
Confluently persistent data structure
Connected component
Connected graph
Co-NP
Constant function
Constraint satisfaction problem
Continuous knapsack problem
Cook reduction
Cook's theorem
Counting sort
Cover
CRCW
Crew
Critical path problem
Cuckoo hashing
Cut
Cutting plane
Cutting stock problem
Cutting theorem
Cut vertex
Cycle sort
Cyclic redundancy check
D-adjacent
DAG shortest paths
Damerau–Levenshtein distance
Data domain
Data structure
Decidability
Decidable language
Decimation
Decision problem
Decision tree
Decomposable searching problem
Degree
Dense graph
Depoissonization
Depth-first search
Depth-limited search
Deque
Derangement
Deterministic algorithm
Deterministic finite automata string search
Deterministic finite automaton
Deterministic finite state machine
Deterministic finite tree automaton
Deterministic pushdown automaton
Deterministic tree automaton
Deutsch–Jozsa algorithm
DFS forest
DFTA
Diagonalization argument
Diameter
Dichotomic search
Dictionary
Difference
Digital circuit
Digital search tree
Digital tree
Dijkstra's algorithm
Diminishing increment sort
Dining philosophers
Direct chaining hashing
Directed acyclic graph
Directed acyclic word graph
Directed graph
Discrete Fourier transform
Discrete interval encoding tree
Discrete p-center
Disjoint set
Disjunction
Distributed algorithm
Distributional complexity
Distribution sort
Divide and conquer algorithm
Divide and marriage before conquest
Division method
Don't care
Doomsday rule
Double-direction bubble sort
Double-ended priority queue
Double hashing
Double left rotation
Double Metaphone
Double right rotation
Doubly ended queue
Doubly linked list
Dragon curve
Dual graph
Dual linear program
Dyadic tree
Dynamic array
Dynamic data structure
Dynamic hashing
Dynamic programming
Dynamization transformation
Edge coloring
Edge connectivity
Edge crossing
Edge-weighted graph
Edit distance
Edit operation
Edit script
Elastic-bucket trie
Element uniqueness
End-of-string
Enfilade
Epidemic algorithm
Euclidean algorithm
Euclidean distance
Euclidean Steiner tree
Euclidean traveling salesman problem
Euclid's algorithm
Euler cycle
Eulerian graph
Eulerian path
Exact string matching
Exchange sort
Exclusive or
Exclusive read, concurrent write
Exclusive read, exclusive write
Exhaustive search
Existential state
Expandable hashing
Expander graph
Exponential
Extended binary tree
Extended Euclidean algorithm
Extended k-d tree
Extendible cell
Extendible hashing
External index
External memory algorithm
External memory data structure
External merge
External merge sort
External node
External quicksort
External radix sort
External sort
Extrapolation search
Extremal
Extreme point
Facility location
Factorial
Fast fourier transform
Fathoming
Feasible region
Feasible solution
Feedback edge set
Feedback vertex set
Ferguson–Forcade algorithm
Fibonacci heap
Fibonacci number
Fibonacci search
Fibonacci tree
FIFO
Find
Find kth least element
Finitary tree
Finite state automaton
Finite state machine
Finite-state machine
Finite state machine minimization
Finite state transducer
First come, first served
Fixed-grid method
Flash sort
Flow
Flow conservation
Flow function
Flow network
Floyd–Warshall algorithm
Ford–Fulkerson algorithm
Forest
Forest editing problem
Formal language
Formal methods
Formal verification
Forward index
Fractal
Fractional knapsack problem
Fractional solution
Free edge
Free list
Free tree
Free vertex
Frequency count heuristic
Full array
Full binary tree
Full inverted index
Fully dynamic graph problem
Fully persistent data structure
Fully polynomial approximation scheme
Function
Functional data structure
Galil–Giancarlo
Galil–Seiferas
Gamma function
GBD-tree
Geometric optimization problem
Global optimum
Glossary of graph theory
Gnome sort
Goobi
Graph
Graph coloring
Graph concentration
Graph drawing
Graph isomorphism
Graph partition
Gray code
Greatest common divisor
Greedy algorithm
Greedy heuristic
Grid drawing
Grid file
Grover's algorithm
Halting problem
Hamiltonian cycle
Hamiltonian path
Hamming distance
Hash collision
Hash function
Hash heap
Hash table
Hash table delete
Hausdorff distance
HB-tree
Heap
Heapify
Heap property
Heapsort
Heaviest common subsequence
Height
Height-balanced binary search tree
Height-balanced tree
Heuristic
Hidden Markov model
Highest common factor
Hilbert curve
Histogram sort
Homeomorphic
Horizontal visibility map
Huffman encoding
Hungarian algorithm
Hybrid algorithm
Hyperedge
Hypergraph
Ideal merge
Identity function
Implies operator
In-branching
Inclusion–exclusion principle
Inclusive or
Incompressible string
Incremental algorithm
In-degree
Independent set
Indeterminacy in computation
Index file
Information theoretic bound
In-order traversal
In-place sort
Insertion sort
Instantaneous description
Integer linear program
Integer multi-commodity flow
Integer polyhedron
Interactive proof system
Interface
Interior-based representation
Internal node
Internal sort
Internet Security Association and Key Management Protocol
Interpolation search
Interpolation-sequential search
Interpolation sort
Intersection
Interval tree
Intractability
Introsort
Introspective sort
Inverse Ackermann function
Inverted file index
Inverted index
Irreflexive
Isomorphic
Iteration
Jaro–Winkler distance
Johnson's algorithm
Jump list
Jump search
Karmarkar's algorithm
Karnaugh map
Karp reduction
K-ary heap
K-ary Huffman encoding
K-ary tree
K-clustering
K-coloring
K-connected graph
K-d-B-tree
K-dimensional
K-dominant match
K-d tree
KmpSkip Search
Knapsack problem
Knight's tour
Knuth–Morris–Pratt algorithm
Kolmogorov complexity
Königsberg bridges problem
Kraft's inequality
Kripke structure
Kruskal's algorithm
Kth order Fibonacci numbers
Kth shortest path
Kth smallest element
KV diagram
K-way merge
K-way merge sort
K-way tree
Labeled graph
Laboratory for Computer Science
Language
Las Vegas algorithm
Lattice
Layered graph
Leaf
Leaf node
Least common multiple
Left-child right-sibling binary tree
Leftist tree
Left rotation
Lempel–Ziv–Welch
Level-order traversal
Levenshtein distance
Lexicographical order
LIFO
Linear
Linear congruential generator
Linear hash
Linear insertion sort
Linear order
Linear probing
Linear probing sort
Linear product
Linear program
Linear quadtree
Linear search
Linked list
List
List contraction
Little-o notation
Lm distance
Load factor
Local alignment
Local optimum
Logarithm
Logarithmic scale
Logical conjunction
Logical disjunction
Logical nand
Logical nor
Longest common subsequence
Longest common substring
Loop
Lotka's law
Lower bound
Lower triangular matrix
Lowest common ancestor
L-reduction
Malhotra–Kumar–Maheshwari blocking flow
Manhattan distance
Many-one reduction
Markov chain
Master theorem
Matched edge
Matched vertex
Matching
Material conditional
Matrix
Matrix-chain multiplication problem
Max-heap property
Maximal independent set
Maximally connected component
Maximal Shift
Maximum bipartite matching
Maximum-flow problem
MAX-SNP
Mealy machine
Mean
Median
Meld
Membership function
Memoization
Memory segment
Merge algorithm
Merge sort
Merkle tree
Meromorphic function
Metaheuristic
Metaphone
Midrange
Miller–Rabin primality test
Min-heap property
Minimal perfect hashing
Minimum bounding box
Minimum cut
Minimum path cover
Minimum spanning tree
Minimum vertex cut
Mixed integer linear program
Mode
Model checking
Model of computation
Moderately exponential
Monotone priority queue
Monotonically decreasing
Monotonically increasing
Monte Carlo algorithm
Moore machine
Morris-Pratt
Move-to-front heuristic
Move-to-root heuristic
Multi-commodity flow
Multigraph
Multilayer grid file
Multiplication method
Multiprefix
Multiprocessor model
Multiset
Multi suffix tree
Multiway decision
Multiway merge
Multiway search tree
Multiway tree
Munkres' assignment algorithm
Naive string search
N-ary function
NC
NC many-one reducibility
Nearest neighbor search
Negation
Network flow problem
New York State Identification and Intelligence System
Next state
NIST
Node
Nonbalanced merge
Nonbalanced merge sort
Nondeterministic algorithm
Nondeterministic finite automaton
Nondeterministic finite state machine
Nondeterministic finite tree automaton
Nondeterministic Turing machine
Nonterminal node
Not So Naive
NP
NP-complete
NP-complete language
NP-hard
N queens
Nullary function
Null tree
Numerical stability
Objective function
Occurrence
Octree
Offline algorithm
Offset
Omega
Omicron
One-based indexing
One-dimensional
Online algorithm
Open addressing
Optimal cost
Optimal hashing
Optimal merge
Optimal mismatch
Optimal polygon triangulation problem
Optimal polyphase merge
Optimal polyphase merge sort
Optimal solution
Optimal triangulation problem
Optimal value
Optimization
Oracle set
Oracle tape
Oracle Turing machine
Ordered array
Ordered binary decision diagram
Ordered linked list
Ordered tree
Order preserving hash
Order preserving minimal perfect hashing
Orders of approximation
Oriented acyclic graph
Oriented graph
Oriented tree
Orthogonal drawing
Orthogonal lists
Orthogonally convex rectilinear polygon
Oscillating merge sort
Out-branching
Out-degree
Overlapping subproblems
Padding argument
Pagoda
Pairing heap
Parallel computation thesis
Parallel prefix computation
Parallel random-access machine
Parametric searching
Parent
Partial function
Partially decidable problem
Partially dynamic graph problem
Partially ordered set
Partially persistent data structure
Partial order
Partial recursive function
Partition
Passive data structure
Path
Path cover
Path system problem
Patience sorting
Patricia tree
Pattern
Pattern element
P-complete
Peano curve
Pearson's hashing
Perfect binary tree
Perfect hashing
Perfect k-ary tree
Perfect matching
Performance guarantee
Performance ratio
Permutation
Persistent data structure
Phencyclidine
Phonetic coding
Pile
Pipelined divide and conquer
Planar graph
Planarization
Planar straight-line graph
PLOP-hashing
Point access method
Pointer jumping
Pointer machine
Poissonization
Polychotomy
Polyhedron
Polylogarithmic
Polynomial
Polynomial hierarchy
Polynomial time
Polynomial-time approximation scheme
Polynomial-time reduction
Polyphase merge
Polyphase merge sort
Polytope
Poset
Post correspondence problem
Postfix traversal
Postman's sort
Postorder traversal
Post–Turing machine
Potential method
Predicate
Prefix
Prefix code
Prefix computation
Prefix sum
Prefix traversal
Preorder traversal
Primary clustering
Primitive recursive
Prim's algorithm
Principle of optimality
Priority queue
Prisoner's dilemma
Probabilistic algorithm
Probabilistically checkable proof
Probabilistic Turing machine
Probe sequence
Procedure
Process algebra
Proper binary tree
Proper coloring
Proper subset
Property list
Prune and search
Pseudorandom number generator
Pth order Fibonacci numbers
P-tree
Public key certificate
Purely functional language
Pushdown automaton
Pushdown transducer
P-way merge sort
Qm sort
Qsort
Quadratic probing
Quadtree
Quadtree complexity theorem
Quad trie
Quantum computation
Queue
Quicksort
Rabin–Karp string search algorithm
Radix quicksort
Radix sort
Ragged matrix
Raita algorithm
Random access machine
Randomization
Randomized algorithm
Randomized binary search tree
Randomized complexity
Randomized polynomial time
Randomized rounding
Randomized search tree
Randomized-Select
Random number generation
Random number generator
Random sampling
Range
Range sort
Rank
Ratcliff/Obershelp pattern recognition
Reachable
Rebalance
Recognizer
Rectangular matrix
Rectilinear Steiner tree
Recurrence equations
Recurrence relation
Recursion
Recursion termination
Recursion tree
Recursive
Recursive data structure
Recursive doubling
Recursive language
Recursively enumerable language
Recursively solvable
Red-black tree
Reduced basis
Reduced digraph
Reduced ordered binary decision diagram
Reduction
Reference
Reflexive relation
Regular decomposition
Rehashing
Relation
Relational structure
Relative performance guarantee
Relaxation technique
Relaxed balance
Rescalable
Restricted universe sort
Result cache
Reverse Colussi
Reverse Factor
R-file
Rice's method
Right rotation
Right-threaded tree
Root
Root balance
Rooted tree
Rotate left
Rotate right
Rotation
Rough graph
RP
R* tree
R+ tree
R-tree
Run time
Saguaro stack
Saturated edge
SBB tree
Scapegoat tree
Search algorithm
Search tree
Search tree property
Secant search
Secondary clustering
Select and partition
Selection algorithm
Selection sort
Select mode
Self-balancing binary search tree
Self-organizing heuristic
Self-organizing list
Self-organizing sequential search
Semidefinite programming
Separate chaining hashing
Separation theorem
Sequential search
Set
Set cover problem
Set packing
Shadow heap
Shadow merge
Shadow merge insert
Shannon–Fano coding
Shared memory
Shell sort
Shift-Or
Shor's algorithm
Shortcutting
Shortest common supersequence problem
Shortest common superstring
Shortest path
Shortest spanning tree
Shuffle
Shuffle sort
Shuffling
Sibling
Sierpiński curve
Sierpinski triangle
Sieve of Eratosthenes
Sift up
Signature
Simon's algorithm
Simple merge
Simple uniform hashing
Simplex communication
Simulated annealing
Simulation theorem
Single-destination shortest-path problem
Single-pair shortest-path problem
Single program multiple data
Single-source shortest-path problem
Singly linked list
Singularity analysis
Sink
Sinking sort
Skd-tree
Skew symmetry
Skip list
Skip search
Slope selection
Smith algorithm
Smith–Waterman algorithm
Smoothsort
Solvable problem
Sort algorithm
Sorted array
Sorted list
Sort in place
Sort merge
Soundex
Space-constructible function
Spanning tree
Sparse graph
Sparse matrix
Sparsification
Sparsity
Spatial index
Spectral test
Splay tree
SPMD
Square matrix
Square root
Stack
Stack tree
Star-shaped polygon
Start state
State
State machine
State transition
Static data structure
Static Huffman encoding
S-t cut
St-digraph
Steiner minimum tree
Steiner ratio
Steiner tree
Steiner tree problem
Steiner vertex
Steinhaus–Johnson–Trotter algorithm
Stirling's approximation
Stirling's formula
Stooge sort
Straight-line drawing
Strand sort
Strictly decreasing
Strictly increasing
Strictly lower triangular matrix
Strictly upper triangular matrix
String
String editing problem
String matching
String matching on ordered alphabets
String matching with errors
String matching with mismatches
String searching
Strip packing
Strongly connected component
Strongly connected graph
Strongly NP-hard
Subadditive ergodic theorem
Subgraph isomorphism
Sublinear time algorithm
Subsequence
Subset
Substring
Subtree
Suffix
Suffix array
Suffix automaton
Suffix tree
Superimposed code
Superset
Supersink
Supersource
Symmetrically linked list
Symmetric binary B-tree
Symmetric min max heap
Symmetric relation
Symmetric set difference
Symmetry breaking
Tail
Tail recursion
Target
Temporal logic
Ternary search
Ternary search tree
Text searching
Theta
Threaded binary tree
Threaded tree
Three-dimensional space
Three-way merge sort
Three-way radix quicksort
Time-constructible function
Time/space complexity
Top-down radix sort
Top-down tree automaton
Top-nodes algorithm
Topological order
Topological sort
Topology tree
Total function
Totally decidable language
Totally decidable problem
Totally undecidable problem
Total order
Tournament
Towers of Hanoi
Tractable problem
Transducer
Transitive closure
Transitive reduction
Transitive relation
Transpose sequential search
Travelling salesman problem
Treap
Tree automaton
Tree contraction
Tree data structure
Tree editing problem
Tree sort
Tree structure
Tree transducer
Tree traversal
Triangle inequality
Triconnected graph
Trie
Trinary function
Tripartition
Turbo-BM
Turbo Reverse Factor
Turing machine
Turing reduction
Turing transducer
Twin grid file
Two-dimensional
Two-level grid file
Two Way algorithm
Two-way linked list
Two-way merge sort
Unary function
Unbounded knapsack problem
Uncomputable function
Uncomputable problem
Undecidable language
Undecidable problem
Undirected graph
Uniform circuit complexity
Uniform circuit family
Uniform hashing
Uniform matrix
Union
Union of automata
Universal hashing
Universal state
Universal Turing machine
Universe
Unsolvable problem
Unsorted list
Upper triangular matrix
Van Emde Boas tree
Vehicle routing problem
Veitch diagram
Venn diagram
Vertex
Vertex coloring
Vertex connectivity
Vertex cover
Vertical visibility map
Virtual hashing
Visibility map
Visible
Viterbi algorithm
VP-tree
Weak cluster
Weak-heap
Weak-heap sort
Weight-balanced tree
Weighted, directed graph
Weighted graph
Work-depth model
Work-efficient
Work-preserving
Worst case
Worst-case cost
Worst-case minimum access
Xor
Yule–Simon distribution
Zeller's congruence
Zhu–Takaoka string matching algorithm
Zipfian distribution
Zipf's law
Zipper
ZPP
